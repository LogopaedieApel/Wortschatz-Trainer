<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="theme-color" content="#27633A">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192x192.png">

    <title>Wortschatz-Trainer</title>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&display=swap" rel="stylesheet">
    <style>
    document.addEventListener('DOMContentLoaded', () => {
    // --- VARIABLEN ---
    let currentMode = null,
        availableItemSets = {},
        masterItems = null, // Für die zentrale Item-Datenbank
        currentItemSetPath = null;
    let currentItemSetData = [],
        currentShuffledItems = [],
        currentItemIndex = 0;
    let currentSettings = {
        displayType: 'image_only',
        displayDuration: 3,
        order: 'chaotic',
        soundOn: true,
        soundDelay: 0
    };
    let soundTimeoutId = null,
        autoNextTimeoutId = null,
        isNavigating = false;
    let progressDotElements = [];
    let currentAudioEndHandler = null;
    let touchStartX = 0,
        touchStartY = 0,
        currentTranslate = 0;

    // --- DOM ELEMENTE ---
    const screens = {
        modeSelection: document.getElementById('screen-mode-selection'),
        settings: document.getElementById('screen-settings'),
        exercise: document.getElementById('screen-exercise')
    };
    const slides = [document.getElementById('slide-1'), document.getElementById('slide-2'), document.getElementById('slide-3')];
    const slidesWrapper = document.querySelector('.slides-wrapper');
    const hamburgerIcon = document.getElementById('hamburger-icon'),
        menuContent = document.getElementById('menu-content');
    const anleitungModal = document.getElementById('anleitung-modal'),
        exerciseEndModal = document.getElementById('exercise-end-modal'),
        modalCloseButtons = document.querySelectorAll('.modal-close-button');
    const modeCards = document.querySelectorAll('.mode-card'),
        settingsTitle = document.getElementById('settings-title');
    const categorySelect = document.getElementById('category-select');
    const subcategoryGroup = document.getElementById('subcategory-group');
    const subcategoryLabel = document.getElementById('subcategory-label');
    const subcategorySelect = document.getElementById('subcategory-select');
    const specGroup = document.getElementById('spec-group');
    const specSelect = document.getElementById('spec-select');
    const settingDisplayTypeGroup = document.getElementById('setting-display-type-group'),
        displayTypeButtons = document.querySelectorAll('#display-type-buttons button');
    const settingOrderGroup = document.getElementById('setting-order-group'),
        orderButtons = document.querySelectorAll('#order-buttons button');
    const settingDisplayDurationGroup = document.getElementById('setting-display-duration-group'),
        displayDurationSelect = document.getElementById('display-duration-select');
    const settingSoundOnOffGroup = document.getElementById('setting-sound-on-off-group'),
        soundOnOffButtons = document.querySelectorAll('#sound-on-off-buttons button');
    const settingSoundDelayGroup = document.getElementById('setting-sound-delay-group'),
        soundDelaySelect = document.getElementById('sound-delay-select');
    const btnSettingsBack = document.getElementById('btn-settings-back'),
        btnStartExercise = document.getElementById('btn-start-exercise'),
        audioPlayer = document.getElementById('audio-player');
    const btnReshuffle = document.getElementById('btn-reshuffle'),
        btnNewSelection = document.getElementById('btn-new-selection');
    const progressDotsContainer = document.getElementById('progress-dots-container');
    const navArrowsLeft = document.querySelectorAll('.nav-arrow-left'),
        navArrowsRight = document.querySelectorAll('.nav-arrow-right');
    const soundButton = document.querySelector('.sound-button');
    const btnStopAutoMode = document.getElementById('btn-stop-auto-mode');
    const arrowGroupLeft = document.getElementById('arrow-group-left'),
        arrowGroupRight = document.getElementById('arrow-group-right');

    // --- FUNKTIONEN ---

    function showScreen(screenIdToShow) {
        Object.values(screens).forEach(screen => {
            const isTarget = screen.id === screenIdToShow;
            screen.classList.toggle('hidden', !isTarget);
            screen.classList.toggle('zoom-out', !isTarget);
            screen.classList.toggle('zoom-in', isTarget);
        });
        document.body.style.overflow = (screenIdToShow === 'screen-exercise') ? 'hidden' : 'auto';
        window.scrollTo(0, 0);
    }

    function showModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) modal.classList.add('show');
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) modal.classList.remove('show');
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Lädt die Set-Struktur (sets.json) und befüllt das erste Dropdown
    async function loadSetsManifest() {
        try {
            const response = await fetch('sets.json?t=' + new Date().getTime());
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            availableItemSets = await response.json();
            categorySelect.innerHTML = '<option value="">Bitte wählen...</option>';
            for (const key in availableItemSets) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = availableItemSets[key].displayName;
                categorySelect.appendChild(option);
            }
            btnStartExercise.disabled = true;
        } catch (e) {
            console.error("Fehler beim Laden von sets.json:", e);
            categorySelect.innerHTML = '<option value="">Fehler beim Laden</option>';
            btnStartExercise.disabled = true;
        }
    }

    // Baut das finale Lernset aus den IDs (aus z.B. sch_initial.json) und den Daten aus master_items.json
    async function loadItemSet(path) {
        if (!path || !masterItems) return false;
        try {
            const response = await fetch(path + '?t=' + new Date().getTime());
            if (!response.ok) throw new Error(`Set-Datei nicht gefunden: ${path}`);
            const itemIds = await response.json();
            if (!Array.isArray(itemIds)) {
                console.error("Set-Datei ist kein Array von IDs:", path);
                currentItemSetData = [];
                return false;
            }
            currentItemSetData = itemIds.map(id => masterItems[id]).filter(item => item !== undefined);
            if (currentItemSetData.length !== itemIds.length) {
                console.warn(`In ${path} wurden eine oder mehrere Item-IDs nicht in master_items.json gefunden.`);
            }
            return true;
        } catch (e) {
            console.error(`Fehler beim Laden oder Verarbeiten des Sets ${path}:`, e);
            currentItemSetData = [];
            return false;
        }
    }

    // Alle weiteren Funktionen (preloadAssets, playCurrentItemSound, etc.) bleiben hier unverändert...
    // Ich füge sie hier der Vollständigkeit halber ein.
    function preloadAssets(items) { const promises = []; const loadedAssets = new Set(); items.forEach(item => { if (item.image && !loadedAssets.has(item.image)) { promises.push(new Promise((resolve) => { const img = new Image(); img.src = item.image + '?t=' + new Date().getTime(); img.onload = resolve; img.onerror = resolve; })); loadedAssets.add(item.image); } if (item.sound && !loadedAssets.has(item.sound)) { promises.push(fetch(item.sound + '?t=' + new Date().getTime()).catch(err => console.error('Preloading sound failed:', err))); loadedAssets.add(item.sound); } }); return Promise.all(promises); }
    function generateProgressDots() { progressDotsContainer.innerHTML = ''; progressDotElements = []; for (let i = 0; i < currentShuffledItems.length; i++) { if(currentShuffledItems[i].type === 'end') continue; const dot = document.createElement('div'); dot.className = 'progress-dot'; progressDotsContainer.appendChild(dot); progressDotElements.push(dot); } }
    function updateProgressDots() { progressDotElements.forEach((dot, index) => { dot.classList.toggle('active', index === currentItemIndex); }); }
    function playCurrentItemSound(delay = 0) { clearTimeout(soundTimeoutId); const item = currentShuffledItems[currentItemIndex]; if (!item || !item.sound) { return; } soundTimeoutId = setTimeout(() => { audioPlayer.pause(); audioPlayer.currentTime = 0; soundButton.disabled = true; const enableButton = () => { soundButton.disabled = false; audioPlayer.removeEventListener('ended', enableButton); audioPlayer.removeEventListener('error', enableButton); }; audioPlayer.addEventListener('canplay', () => audioPlayer.play().catch(e => console.error("Sound-Abspielfehler:", e)), { once: true }); audioPlayer.addEventListener('ended', enableButton, { once: true }); audioPlayer.addEventListener('error', enableButton, { once: true }); audioPlayer.src = item.sound + '?t=' + new Date().getTime(); }, delay * 1000); }
    function stopAllAutomation() { clearTimeout(soundTimeoutId); clearTimeout(autoNextTimeoutId); audioPlayer.pause(); if (currentAudioEndHandler) { audioPlayer.removeEventListener('ended', currentAudioEndHandler); audioPlayer.removeEventListener('error', currentAudioEndHandler); currentAudioEndHandler = null; } if (currentMode === 'manual') { soundButton.disabled = false; audioPlayer.src = ''; } }
    function exitCurrentExercise() { stopAllAutomation(); }
    function populateSlide(slideElement, itemIndex) { const item = currentShuffledItems[itemIndex]; slideElement.innerHTML = ''; if (!item || item.type === 'end') return; let displayImage = false, displayWord = false, imagePath = item.image ? item.image.trim() : ""; if (currentSettings.displayType === 'image_only') displayImage = true; if (currentSettings.displayType === 'word_only') displayWord = true; if (currentSettings.displayType === 'image_word') { displayImage = true; displayWord = true; } if (displayImage && !imagePath) { displayImage = false; displayWord = true; } if (displayImage && imagePath) { const img = document.createElement('img'); img.src = imagePath + '?t=' + new Date().getTime(); img.alt = item.name || ""; if (currentMode === 'manual') { img.addEventListener('click', () => moveSlider(-1)); } slideElement.appendChild(img); } if (displayWord) { const p = document.createElement('p'); p.className = 'word-text'; p.textContent = item.name || ""; slideElement.appendChild(p); } }
    function setSlidePositions(animated = true) { slides.forEach(s => s.classList.toggle('no-transition', !animated)); const prevIndex = (currentItemIndex - 1 + currentShuffledItems.length) % currentShuffledItems.length; const nextIndex = (currentItemIndex + 1) % currentShuffledItems.length; populateSlide(prevSlide, prevIndex); populateSlide(currentSlide, currentItemIndex); populateSlide(nextSlide, nextIndex); prevSlide.style.transform = `translateX(-100%)`; currentSlide.style.transform = `translateX(0)`; nextSlide.style.transform = `translateX(100%)`; if (!animated) { setTimeout(() => slides.forEach(s => s.classList.remove('no-transition')), 20); } }
    function updateExerciseUIForMode() { const isManual = currentMode === 'manual'; arrowGroupLeft.classList.toggle('hidden', !isManual); arrowGroupRight.classList.toggle('hidden', !isManual); soundButton.classList.toggle('hidden', !isManual); btnStopAutoMode.classList.toggle('hidden', isManual); }
    function setupInitialState() { isNavigating = false; setSlidePositions(false); updateExerciseUIForMode(); updateUiForCurrentItem(); }
    function handleTransitionEnd(direction) { const prevIndex = (currentItemIndex - 1 + currentShuffledItems.length) % currentShuffledItems.length; const nextIndex = (currentItemIndex + 1) % currentShuffledItems.length; const slideToReset = direction === -1 ? nextSlide : prevSlide; const indexToPopulate = direction === -1 ? nextIndex : prevIndex; const positionToSet = direction === -1 ? '100%' : '-100%'; slideToReset.classList.add('no-transition'); populateSlide(slideToReset, indexToPopulate); slideToReset.style.transform = `translateX(${positionToSet})`; setTimeout(() => { slideToReset.classList.remove('no-transition'); isNavigating = false; }, 20); }
    function runAutoModeStep() { stopAllAutomation(); const item = currentShuffledItems[currentItemIndex]; const hasSound = item && item.sound && currentSettings.soundOn; let displayDurationFinished = false; let soundPlaybackFinished = !hasSound; const tryProceedToNext = () => { if (displayDurationFinished && soundPlaybackFinished) { moveSlider(-1); } }; autoNextTimeoutId = setTimeout(() => { displayDurationFinished = true; tryProceedToNext(); }, currentSettings.displayDuration * 1000); if (hasSound) { playCurrentItemSound(currentSettings.soundDelay); currentAudioEndHandler = () => { soundPlaybackFinished = true; tryProceedToNext(); }; audioPlayer.addEventListener('ended', currentAudioEndHandler, { once: true }); audioPlayer.addEventListener('error', currentAudioEndHandler, { once: true }); } }
    function updateUiForCurrentItem() { updateProgressDots(); const item = currentShuffledItems[currentItemIndex]; const hasSound = item && item.sound; soundButton.classList.toggle('invisible', !hasSound); if (currentMode === 'auto') { runAutoModeStep(); } }
    function touchStart(event) { if (isNavigating || currentMode === 'auto') return; touchStartX = event.type.includes('mouse') ? event.pageX : event.touches[0].clientX; touchStartY = event.type.includes('mouse') ? event.pageY : event.touches[0].clientY; slides.forEach(s => s.classList.add('is-grabbing')); slidesWrapper.addEventListener('touchmove', touchMove); slidesWrapper.addEventListener('touchend', touchEnd); }
    function touchMove(event) { if (isNavigating || currentMode === 'auto') return; const currentX = event.type.includes('mouse') ? event.pageX : event.touches[0].clientX; const currentY = event.type.includes('mouse') ? event.pageY : event.touches[0].clientY; const deltaX = currentX - touchStartX; const deltaY = Math.abs(currentY - touchStartY); if (Math.abs(deltaX) < deltaY && !currentTranslate) return; currentTranslate = deltaX; prevSlide.style.transform = `translateX(calc(-100% + ${deltaX}px))`; currentSlide.style.transform = `translateX(${deltaX}px)`; nextSlide.style.transform = `translateX(calc(100% + ${deltaX}px))`; }
    function touchEnd() { if (currentMode === 'auto') return; slidesWrapper.removeEventListener('touchmove', touchMove); slidesWrapper.removeEventListener('touchend', touchEnd); slides.forEach(s => s.classList.remove('is-grabbing')); const threshold = slidesWrapper.clientWidth / 4; let direction = 0; if (Math.abs(currentTranslate) > threshold) { direction = currentTranslate < 0 ? -1 : 1; } moveSlider(direction); currentTranslate = 0; }
    function moveSlider(direction) { if (isNavigating || direction === 0) { if(direction === 0) setSlidePositions(); return; } if (currentMode === 'manual') { stopAllAutomation(); } isNavigating = true; let newIndex = currentItemIndex - direction; if (newIndex >= currentShuffledItems.length || (currentShuffledItems[newIndex] && currentShuffledItems[newIndex].type === 'end')) { exitCurrentExercise(); btnReshuffle.textContent = (currentSettings.order === 'chaotic') ? 'Neu mischen' : 'Neu starten'; showModal('exercise-end-modal'); isNavigating = false; return; } if (newIndex < 0) { newIndex = currentShuffledItems.length - 1; } currentItemIndex = newIndex; currentSlide.style.transform = `translateX(${direction * 100}%)`; let tempSlide; if (direction === -1) { nextSlide.style.transform = `translateX(0)`; tempSlide = prevSlide; prevSlide = currentSlide; currentSlide = nextSlide; nextSlide = tempSlide; } else { prevSlide.style.transform = `translateX(0)`; tempSlide = nextSlide; nextSlide = currentSlide; currentSlide = prevSlide; prevSlide = tempSlide; } currentSlide.addEventListener('transitionend', () => handleTransitionEnd(direction), { once: true }); updateUiForCurrentItem(); }
    function populateDisplayDurationSelect() { displayDurationSelect.innerHTML = ''; for (let i = 1; i <= 10; i++) { const option = document.createElement('option'); option.value = i; option.textContent = i === 1 ? '1 Sekunde' : `${i} Sekunden`; displayDurationSelect.appendChild(option); } displayDurationSelect.value = currentSettings.displayDuration; }
    function populateSoundDelaySelect() { soundDelaySelect.innerHTML = ''; for (let i = 0; i <= 5; i += 0.5) { const option = document.createElement('option'); option.value = i; option.textContent = i === 0 ? '0 Sek (sofort)' : `${i.toFixed(1)} Sek`; soundDelaySelect.appendChild(option); } }
    function configureSettingsScreen() { let modeText = (currentMode === 'manual') ? 'Manuell' : 'Automatisch'; settingsTitle.textContent = `Einstellungen für: ${modeText}`; const isAutoMode = currentMode === 'auto'; settingOrderGroup.classList.toggle('hidden', !isAutoMode); settingDisplayDurationGroup.classList.toggle('hidden', !isAutoMode); settingSoundOnOffGroup.classList.toggle('hidden', !isAutoMode); const showSoundDelay = isAutoMode && currentSettings.soundOn; settingSoundDelayGroup.classList.toggle('hidden', !showSoundDelay); }

    // --- EVENT LISTENERS ---

    // Dropdown-Logik
    categorySelect.addEventListener('change', () => {
        const selectedCategoryKey = categorySelect.value;
        subcategoryGroup.classList.add('hidden');
        specGroup.classList.add('hidden');
        subcategorySelect.innerHTML = '';
        specSelect.innerHTML = '';
        btnStartExercise.disabled = true;
        currentItemSetPath = null;
        if (!selectedCategoryKey) return;
        const categoryData = availableItemSets[selectedCategoryKey];
        const subcategories = categoryData.laute || categoryData.felder || categoryData.stufen;
        subcategoryLabel.textContent = categoryData.unterkategorieName + ':';
        subcategorySelect.innerHTML = '<option value="">Bitte wählen...</option>';
        for (const key in subcategories) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = subcategories[key].displayName;
            subcategorySelect.appendChild(option);
        }
        subcategoryGroup.classList.remove('hidden');
    });

    subcategorySelect.addEventListener('change', () => {
        const selectedCategoryKey = categorySelect.value;
        const selectedSubCategoryKey = subcategorySelect.value;
        specGroup.classList.add('hidden');
        specSelect.innerHTML = '';
        btnStartExercise.disabled = true;
        currentItemSetPath = null;
        if (!selectedSubCategoryKey) return;
        const subCategoryData = (availableItemSets[selectedCategoryKey].laute || availableItemSets[selectedCategoryKey].felder || availableItemSets[selectedCategoryKey].stufen)[selectedSubCategoryKey];
        if (subCategoryData.path) {
            currentItemSetPath = subCategoryData.path;
            btnStartExercise.disabled = false;
        } else if (subCategoryData.positionen) {
            specSelect.innerHTML = '<option value="">Bitte wählen...</option>';
            for (const key in subCategoryData.positionen) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = subCategoryData.positionen[key].displayName;
                specSelect.appendChild(option);
            }
            specGroup.classList.remove('hidden');
        }
    });

    specSelect.addEventListener('change', () => {
        const selectedCategoryKey = categorySelect.value;
        const selectedSubCategoryKey = subcategorySelect.value;
        const selectedSpecKey = specSelect.value;
        btnStartExercise.disabled = true;
        currentItemSetPath = null;
        if (!selectedSpecKey) return;
        const specData = availableItemSets[selectedCategoryKey].laute[selectedSubCategoryKey].positionen[selectedSpecKey];
        if (specData && specData.path) {
            currentItemSetPath = specData.path;
            btnStartExercise.disabled = false;
        }
    });

    // Andere UI-Elemente
    hamburgerIcon.addEventListener('click', (e) => { e.stopPropagation(); menuContent.classList.toggle('show'); if (currentMode === 'auto') { stopAllAutomation(); } });
    document.addEventListener('click', () => { if (menuContent.classList.contains('show')) menuContent.classList.remove('show'); });
    document.getElementById('menu-anleitung').addEventListener('click', (e) => { e.preventDefault(); showModal('anleitung-modal'); menuContent.classList.remove('show'); });
    document.getElementById('menu-modus-auswahl').addEventListener('click', (e) => { e.preventDefault(); exitCurrentExercise(); showScreen('screen-mode-selection'); menuContent.classList.remove('show'); });
    ['manual', 'auto'].forEach(modeKey => { document.getElementById(`menu-${modeKey}`).addEventListener('click', (e) => { e.preventDefault(); exitCurrentExercise(); currentMode = modeKey; configureSettingsScreen(); showScreen('screen-settings'); menuContent.classList.remove('show'); }); });
    modalCloseButtons.forEach(b => b.addEventListener('click', () => closeModal(b.dataset.modalId)));
    window.addEventListener('click', (e) => { if (e.target.classList.contains('modal')) closeModal(e.target.id); });
    modeCards.forEach(c => c.addEventListener('click', () => { currentMode = c.dataset.mode; configureSettingsScreen(); showScreen('screen-settings'); }));
    displayTypeButtons.forEach(b => b.addEventListener('click', () => { displayTypeButtons.forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); currentSettings.displayType = b.dataset.displayType; }));
    orderButtons.forEach(b => b.addEventListener('click', () => { orderButtons.forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); currentSettings.order = b.dataset.order; }));
    displayDurationSelect.addEventListener('change', (e) => { currentSettings.displayDuration = parseInt(e.target.value); });
    soundOnOffButtons.forEach(b => b.addEventListener('click', () => { soundOnOffButtons.forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); currentSettings.soundOn = b.dataset.soundOn === 'true'; configureSettingsScreen(); }));
    soundDelaySelect.addEventListener('change', (e) => { currentSettings.soundDelay = parseFloat(e.target.value); });
    btnSettingsBack.addEventListener('click', () => showScreen('screen-mode-selection'));
    btnStartExercise.addEventListener('click', async () => {
        const loaded = await loadItemSet(currentItemSetPath);
        if (!loaded || !currentItemSetData || currentItemSetData.length === 0) {
            alert("Dieses Lernset ist leer oder konnte nicht geladen werden. Bitte wählen Sie ein anderes aus.");
            return;
        }
        document.getElementById('loading-overlay').classList.remove('hidden');
        let baseItems = [...currentItemSetData];
        currentShuffledItems = (currentSettings.order === 'chaotic' && currentMode === 'auto') ? shuffleArray(baseItems) : baseItems;
        currentShuffledItems.push({ type: 'end' });
        currentItemIndex = 0;
        await preloadAssets(currentShuffledItems);
        generateProgressDots();
        setupInitialState();
        setTimeout(() => { document.getElementById('loading-overlay').classList.add('hidden'); showScreen('screen-exercise'); }, 200);
    });
    btnReshuffle.addEventListener('click', () => { closeModal('exercise-end-modal'); btnStartExercise.click(); });
    btnNewSelection.addEventListener('click', () => { closeModal('exercise-end-modal'); exitCurrentExercise(); showScreen('screen-settings'); });
    soundButton.addEventListener('click', () => playCurrentItemSound(0));
    navArrowsLeft.forEach(arrow => arrow.addEventListener('click', () => moveSlider(1)));
    navArrowsRight.forEach(arrow => arrow.addEventListener('click', () => moveSlider(-1)));
    btnStopAutoMode.addEventListener('click', () => { exitCurrentExercise(); configureSettingsScreen(); showScreen('screen-settings'); });
    slidesWrapper.addEventListener('touchstart', touchStart, { passive: true });

    // --- INITIALISIERUNG ---
    async function initializeApp() {
        populateDisplayDurationSelect();
        populateSoundDelaySelect();

        // Schritt 1: Lade die zentrale Item-Datenbank. Dies MUSS zuerst geschehen.
        try {
            const response = await fetch('data/master_items.json?t=' + new Date().getTime());
            if (!response.ok) throw new Error('Master-Item-Liste nicht gefunden');
            masterItems = await response.json();
        } catch (e) {
            console.error("KRITISCHER FEHLER: master_items.json konnte nicht geladen werden.", e);
            document.body.innerHTML = '<h1>Fehler</h1><p>Die Haupt-Datenbank der App (master_items.json) konnte nicht geladen werden. Bitte stellen Sie sicher, dass die Datei im "data"-Ordner liegt und der Name korrekt ist.</p>';
            return; // App-Initialisierung abbrechen
        }

        // Schritt 2: Lade die Set-Struktur für die Dropdowns.
        await loadSetsManifest();

        // Schritt 3: Zeige den Startbildschirm.
        showScreen('screen-mode-selection');
    }

    initializeApp();
});
</style>
</head>
<body>
    <div id="loading-overlay" class="hidden">
        <div class="loading-spinner"></div>
        <p>Lade Inhalte...</p>
    </div>

    <div class="hamburger-menu"><span class="hamburger-icon" id="hamburger-icon">☰</span><div class="menu-content" id="menu-content"><ul><li><a href="#" id="menu-anleitung">Anleitung</a></li><li><a href="#" id="menu-manual">Manuell</a></li><li><a href="#" id="menu-auto">Automatisch</a></li><li><a href="#" id="menu-modus-auswahl">Zur Modus-Auswahl</a></li></ul></div></div>
    
    <div id="anleitung-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button" data-modal-id="anleitung-modal">×</span>
            <h2>Anleitung</h2>
            <!-- Inhalt der Anleitung unverändert -->
        </div>
    </div>

    <div id="exercise-end-modal" class="modal"><div class="modal-content"><span class="modal-close-button" data-modal-id="exercise-end-modal">×</span><h2>Übung beendet!</h2><p id="exercise-end-message">Alle Items bearbeitet.</p><div style="text-align: center; margin-top: 20px; display: flex; justify-content: space-around;"><button id="btn-reshuffle">Neu starten</button><button id="btn-new-selection">Neue Auswahl</button></div></div></div>
    
    <div id="screen-mode-selection" class="screen">
        <h1>Wortschatz-Trainer</h1>
        <h2>Modus auswählen</h2>
        <div class="mode-selection-container">
            <div class="mode-card clickable-card" data-mode="manual">
                <img src="manuell.png" alt="Manuell Modus">
                <span class="subtitle">Manuell</span>
            </div>
            <div class="mode-card clickable-card" data-mode="auto">
                <img src="automatisch.jpg" alt="Automatisch Modus">
                <span class="subtitle">Automatisch</span>
            </div>
        </div>
        <img src="logo.png" alt="Logo" class="site-logo">
    </div>
    
    <div id="screen-settings" class="screen hidden">
        <h2 id="settings-title">Einstellungen</h2>
        <div class="settings-form">
            
            <div class="form-group">
                <label for="category-select">Bereich:</label>
                <select id="category-select">
                    <option value="">Lade Sets...</option>
                </select>
            </div>

            <div class="form-group hidden" id="subcategory-group">
                <label for="subcategory-select" id="subcategory-label">Detail:</label>
                <select id="subcategory-select"></select>
            </div>

            <div class="form-group hidden" id="spec-group">
                <label for="spec-select">Position im Wort:</label>
                <select id="spec-select"></select>
            </div>

            <div class="form-group" id="setting-display-type-group">
                <label>Anzeige:</label>
                <div class="setting-button-group" id="display-type-buttons">
                    <button data-display-type="image_only" class="selected">Nur Bild</button>
                    <button data-display-type="word_only">Nur Wort</button>
                    <button data-display-type="image_word">Bild & Wort</button>
                </div>
            </div>
            <div class="form-group hidden" id="setting-order-group">
                <label>Reihenfolge:</label>
                <div class="setting-button-group" id="order-buttons">
                    <button data-order="chaotic" class="selected">Chaotisch</button>
                    <button data-order="ordered">Geordnet</button>
                </div>
            </div>
            <div class="form-group hidden" id="setting-display-duration-group">
                <label for="display-duration-select">Minimale Anzeigedauer:</label>
                <select id="display-duration-select"></select>
            </div>
            <div class="form-group hidden" id="setting-sound-on-off-group">
                <label>Ton:</label>
                <div class="setting-button-group" id="sound-on-off-buttons">
                    <button data-sound-on="true" class="selected">An</button>
                    <button data-sound-on="false">Aus</button>
                </div>
            </div>
            <div class="form-group hidden" id="setting-sound-delay-group">
                <label for="sound-delay-select">Ton-Verzögerung:</label>
                <select id="sound-delay-select"></select>
            </div>

            <div style="display: flex; justify-content: space-between; margin-top: 30px;">
                <button id="btn-settings-back">Zurück</button>
                <button id="btn-start-exercise">Start</button>
            </div>
        </div>
    </div>
    
    <div id="screen-exercise" class="screen hidden">
        <!-- Inhalt von screen-exercise unverändert -->
    </div>
    
    <audio id="audio-player"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // HIER BEGINNEN DIE JAVASCRIPT-ÄNDERUNGEN
            let currentMode = null;
            let availableItemSets = {};
            let masterItems = null; // NEU: Variable für die Master-Liste
            let currentItemSetPath = null;
            // Der Rest der Variablen bleibt gleich wie zuvor...
            let currentItemSetData = [], currentShuffledItems = [], currentItemIndex = 0;
            let currentSettings = { 
                displayType: 'image_only', 
                displayDuration: 3, 
                order: 'chaotic',
                soundOn: true,
                soundDelay: 0
            };
            let soundTimeoutId = null, autoNextTimeoutId = null, isNavigating = false;
            let progressDotElements = [];
            let currentAudioEndHandler = null;
            
            let touchStartX = 0, touchStartY = 0, currentTranslate = 0;
            const slides = [document.getElementById('slide-1'), document.getElementById('slide-2'), document.getElementById('slide-3')];
            let prevSlide = slides[0], currentSlide = slides[1], nextSlide = slides[2];

            // DOM-Elemente holen (unverändert)
            const screens = { modeSelection: document.getElementById('screen-mode-selection'), settings: document.getElementById('screen-settings'), exercise: document.getElementById('screen-exercise') };
            const slidesWrapper = document.querySelector('.slides-wrapper');
            const hamburgerIcon = document.getElementById('hamburger-icon'), menuContent = document.getElementById('menu-content');
            const anleitungModal = document.getElementById('anleitung-modal'), exerciseEndModal = document.getElementById('exercise-end-modal'), modalCloseButtons = document.querySelectorAll('.modal-close-button');
            const modeCards = document.querySelectorAll('.mode-card'), settingsTitle = document.getElementById('settings-title');
            
            const categorySelect = document.getElementById('category-select');
            const subcategoryGroup = document.getElementById('subcategory-group');
            const subcategoryLabel = document.getElementById('subcategory-label');
            const subcategorySelect = document.getElementById('subcategory-select');
            const specGroup = document.getElementById('spec-group');
            const specSelect = document.getElementById('spec-select');
            
            const settingDisplayTypeGroup = document.getElementById('setting-display-type-group'), displayTypeButtons = document.querySelectorAll('#display-type-buttons button');
            const settingOrderGroup = document.getElementById('setting-order-group'), orderButtons = document.querySelectorAll('#order-buttons button');
            const settingDisplayDurationGroup = document.getElementById('setting-display-duration-group'), displayDurationSelect = document.getElementById('display-duration-select');
            const settingSoundOnOffGroup = document.getElementById('setting-sound-on-off-group'), soundOnOffButtons = document.querySelectorAll('#sound-on-off-buttons button');
            const settingSoundDelayGroup = document.getElementById('setting-sound-delay-group'), soundDelaySelect = document.getElementById('sound-delay-select');
            
            const btnSettingsBack = document.getElementById('btn-settings-back'), btnStartExercise = document.getElementById('btn-start-exercise'), audioPlayer = document.getElementById('audio-player');
            const btnReshuffle = document.getElementById('btn-reshuffle'), btnNewSelection = document.getElementById('btn-new-selection');
            const progressDotsContainer = document.getElementById('progress-dots-container');
            const navArrowsLeft = document.querySelectorAll('.nav-arrow-left'), navArrowsRight = document.querySelectorAll('.nav-arrow-right');
            const soundButton = document.querySelector('.sound-button');
            const btnStopAutoMode = document.getElementById('btn-stop-auto-mode');
            const arrowGroupLeft = document.getElementById('arrow-group-left'), arrowGroupRight = document.getElementById('arrow-group-right');
            
            // Hilfsfunktionen (unverändert)
            function showScreen(screenIdToShow) { Object.values(screens).forEach(screen => { const isTarget = screen.id === screenIdToShow; screen.classList.toggle('hidden', !isTarget); screen.classList.toggle('zoom-out', !isTarget); screen.classList.toggle('zoom-in', isTarget); }); document.body.style.overflow = (screenIdToShow === 'screen-exercise') ? 'hidden' : 'auto'; window.scrollTo(0,0); }
            function showModal(modalId) { const modal = document.getElementById(modalId); if (modal) modal.classList.add('show'); }
            function closeModal(modalId) { const modal = document.getElementById(modalId); if (modal) modal.classList.remove('show'); }
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            
            function preloadAssets(items) {
                const promises = []; const loadedAssets = new Set();
                items.forEach(item => {
                    if (item.image && !loadedAssets.has(item.image)) { promises.push(new Promise((resolve) => { const img = new Image(); img.src = item.image + '?t=' + new Date().getTime(); img.onload = resolve; img.onerror = resolve; })); loadedAssets.add(item.image); }
                    if (item.sound && !loadedAssets.has(item.sound)) { promises.push(fetch(item.sound + '?t=' + new Date().getTime()).catch(err => console.error('Preloading sound failed:', err))); loadedAssets.add(item.sound); }
                }); return Promise.all(promises);
            }

            // ANGEPASSTE Ladelogik
            async function loadSetsManifest() {
                try {
                    const response = await fetch('sets.json?t=' + new Date().getTime());
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    availableItemSets = await response.json();
                    
                    categorySelect.innerHTML = '<option value="">Bitte wählen...</option>';
                    
                    for (const key in availableItemSets) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = availableItemSets[key].displayName;
                        categorySelect.appendChild(option);
                    }
                    
                    btnStartExercise.disabled = true;
                    return true;
                } catch (e) {
                    console.error("Fehler beim Laden von sets.json:", e);
                    categorySelect.innerHTML = '<option value="">Fehler beim Laden</option>';
                    btnStartExercise.disabled = true;
                    return false;
                }
            }

            // NEU: ANGEPASSTE loadItemSet FUNKTION, die IDs mit der Master-Liste abgleicht
            async function loadItemSet(path) {
                if (!path || !masterItems) {
                    console.error("Fehler: Pfad oder Master-Item-Liste fehlt.");
                    return false;
                }
                
                try {
                    const response = await fetch(path + '?t=' + new Date().getTime());
                    if (!response.ok) throw new Error(`Set-Datei nicht gefunden: ${path}`);
                    
                    const itemIds = await response.json(); // Lädt die Liste der Item-IDs
                    if (!Array.isArray(itemIds)) {
                        console.error("Set-Datei ist kein Array von IDs:", path);
                        currentItemSetData = [];
                        return false;
                    }

                    // "Hydriert" die IDs mit den Daten aus der Master-Liste
                    currentItemSetData = itemIds
                        .map(id => masterItems[id])
                        .filter(item => item !== undefined); 

                    if (currentItemSetData.length !== itemIds.length) {
                        console.warn(`Warnung: In ${path} wurden nicht alle IDs in master_items.json gefunden.`);
                    }

                    return true;

                } catch (e) {
                    console.error(`Fehler beim Laden oder Verarbeiten des Sets ${path}:`, e);
                    currentItemSetData = [];
                    return false;
                }
            }

            // Dropdown Event-Listener (unverändert zur letzten Version)
            categorySelect.addEventListener('change', () => {
                const selectedCategoryKey = categorySelect.value;
                subcategoryGroup.classList.add('hidden');
                specGroup.classList.add('hidden');
                subcategorySelect.innerHTML = '';
                specSelect.innerHTML = '';
                btnStartExercise.disabled = true;
                currentItemSetPath = null;
                if (!selectedCategoryKey) return;
                const categoryData = availableItemSets[selectedCategoryKey];
                const subcategories = categoryData.laute || categoryData.felder || categoryData.stufen;
                subcategoryLabel.textContent = categoryData.unterkategorieName + ':';
                subcategorySelect.innerHTML = '<option value="">Bitte wählen...</option>';
                for (const key in subcategories) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = subcategories[key].displayName;
                    subcategorySelect.appendChild(option);
                }
                subcategoryGroup.classList.remove('hidden');
            });
            subcategorySelect.addEventListener('change', () => {
                const selectedCategoryKey = categorySelect.value;
                const selectedSubCategoryKey = subcategorySelect.value;
                specGroup.classList.add('hidden');
                specSelect.innerHTML = '';
                btnStartExercise.disabled = true;
                currentItemSetPath = null;
                if (!selectedSubCategoryKey) return;
                const subCategoryData = (availableItemSets[selectedCategoryKey].laute || availableItemSets[selectedCategoryKey].felder || availableItemSets[selectedCategoryKey].stufen)[selectedSubCategoryKey];
                if (subCategoryData.path) {
                    currentItemSetPath = subCategoryData.path;
                    btnStartExercise.disabled = false;
                } else if (subCategoryData.positionen) {
                    specSelect.innerHTML = '<option value="">Bitte wählen...</option>';
                    for (const key in subCategoryData.positionen) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = subCategoryData.positionen[key].displayName;
                        specSelect.appendChild(option);
                    }
                    specGroup.classList.remove('hidden');
                }
            });
            specSelect.addEventListener('change', () => {
                const selectedCategoryKey = categorySelect.value;
                const selectedSubCategoryKey = subcategorySelect.value;
                const selectedSpecKey = specSelect.value;
                btnStartExercise.disabled = true;
                currentItemSetPath = null;
                if (!selectedSpecKey) return;
                const specData = availableItemSets[selectedCategoryKey].laute[selectedSubCategoryKey].positionen[selectedSpecKey];
                if (specData && specData.path) {
                    currentItemSetPath = specData.path;
                    btnStartExercise.disabled = false;
                }
            });

            // Der Rest des Codes (Übungslogik, UI-Updates etc.) ist größtenteils unverändert
            // ... (Hier folgt der Code von "generateProgressDots" bis "btnStopAutoMode.addEventListener") ...
            // Der Code-Block ist sehr lang, daher lasse ich ihn hier weg, er bleibt aber im finalen Skript enthalten.
            // Die Logik innerhalb dieser Funktionen muss nicht geändert werden, da sie mit `currentItemSetData` arbeitet,
            // und diese Variable wird ja von unserer neuen `loadItemSet`-Funktion korrekt befüllt.

            // Beispielhaft eine der unveränderten Funktionen:
            function generateProgressDots() { progressDotsContainer.innerHTML = ''; progressDotElements = []; for (let i = 0; i < currentShuffledItems.length; i++) { if(currentShuffledItems[i].type === 'end') continue; const dot = document.createElement('div'); dot.className = 'progress-dot'; progressDotsContainer.appendChild(dot); progressDotElements.push(dot); } }
            // ... alle anderen Funktionen folgen hier ...
            function updateProgressDots() { progressDotElements.forEach((dot, index) => { dot.classList.toggle('active', index === currentItemIndex); }); }
            function playCurrentItemSound(delay = 0) { clearTimeout(soundTimeoutId); const item = currentShuffledItems[currentItemIndex]; if (!item || !item.sound) { return; } soundTimeoutId = setTimeout(() => { audioPlayer.pause(); audioPlayer.currentTime = 0; soundButton.disabled = true; const enableButton = () => { soundButton.disabled = false; audioPlayer.removeEventListener('ended', enableButton); audioPlayer.removeEventListener('error', enableButton); }; audioPlayer.addEventListener('canplay', () => audioPlayer.play().catch(e => console.error("Sound-Abspielfehler:", e)), { once: true }); audioPlayer.addEventListener('ended', enableButton, { once: true }); audioPlayer.addEventListener('error', enableButton, { once: true }); audioPlayer.src = item.sound + '?t=' + new Date().getTime(); }, delay * 1000); }
            function stopAllAutomation() { clearTimeout(soundTimeoutId); clearTimeout(autoNextTimeoutId); audioPlayer.pause(); if (currentAudioEndHandler) { audioPlayer.removeEventListener('ended', currentAudioEndHandler); audioPlayer.removeEventListener('error', currentAudioEndHandler); currentAudioEndHandler = null; } if (currentMode === 'manual') { soundButton.disabled = false; audioPlayer.src = ''; } }
            function exitCurrentExercise() { stopAllAutomation(); }
            function populateSlide(slideElement, itemIndex) { const item = currentShuffledItems[itemIndex]; slideElement.innerHTML = ''; if (!item || item.type === 'end') return; let displayImage = false, displayWord = false, imagePath = item.image ? item.image.trim() : ""; if (currentSettings.displayType === 'image_only') displayImage = true; if (currentSettings.displayType === 'word_only') displayWord = true; if (currentSettings.displayType === 'image_word') { displayImage = true; displayWord = true; } if (displayImage && !imagePath) { displayImage = false; displayWord = true; } if (displayImage && imagePath) { const img = document.createElement('img'); img.src = imagePath + '?t=' + new Date().getTime(); img.alt = item.name || ""; if (currentMode === 'manual') { img.addEventListener('click', () => moveSlider(-1)); } slideElement.appendChild(img); } if (displayWord) { const p = document.createElement('p'); p.className = 'word-text'; p.textContent = item.name || ""; slideElement.appendChild(p); } }
            function setSlidePositions(animated = true) { slides.forEach(s => s.classList.toggle('no-transition', !animated)); const prevIndex = (currentItemIndex - 1 + currentShuffledItems.length) % currentShuffledItems.length; const nextIndex = (currentItemIndex + 1) % currentShuffledItems.length; populateSlide(prevSlide, prevIndex); populateSlide(currentSlide, currentItemIndex); populateSlide(nextSlide, nextIndex); prevSlide.style.transform = `translateX(-100%)`; currentSlide.style.transform = `translateX(0)`; nextSlide.style.transform = `translateX(100%)`; if (!animated) { setTimeout(() => slides.forEach(s => s.classList.remove('no-transition')), 20); } }
            function updateExerciseUIForMode() { const isManual = currentMode === 'manual'; arrowGroupLeft.classList.toggle('hidden', !isManual); arrowGroupRight.classList.toggle('hidden', !isManual); soundButton.classList.toggle('hidden', !isManual); btnStopAutoMode.classList.toggle('hidden', isManual); }
            function setupInitialState() { isNavigating = false; setSlidePositions(false); updateExerciseUIForMode(); updateUiForCurrentItem(); }
            function handleTransitionEnd(direction) { const prevIndex = (currentItemIndex - 1 + currentShuffledItems.length) % currentShuffledItems.length; const nextIndex = (currentItemIndex + 1) % currentShuffledItems.length; const slideToReset = direction === -1 ? nextSlide : prevSlide; const indexToPopulate = direction === -1 ? nextIndex : prevIndex; const positionToSet = direction === -1 ? '100%' : '-100%'; slideToReset.classList.add('no-transition'); populateSlide(slideToReset, indexToPopulate); slideToReset.style.transform = `translateX(${positionToSet})`; setTimeout(() => { slideToReset.classList.remove('no-transition'); isNavigating = false; }, 20); }
            function runAutoModeStep() { stopAllAutomation(); const item = currentShuffledItems[currentItemIndex]; const hasSound = item && item.sound && currentSettings.soundOn; let displayDurationFinished = false; let soundPlaybackFinished = !hasSound; const tryProceedToNext = () => { if (displayDurationFinished && soundPlaybackFinished) { moveSlider(-1); } }; autoNextTimeoutId = setTimeout(() => { displayDurationFinished = true; tryProceedToNext(); }, currentSettings.displayDuration * 1000); if (hasSound) { playCurrentItemSound(currentSettings.soundDelay); currentAudioEndHandler = () => { soundPlaybackFinished = true; tryProceedToNext(); }; audioPlayer.addEventListener('ended', currentAudioEndHandler, { once: true }); audioPlayer.addEventListener('error', currentAudioEndHandler, { once: true }); } }
            function updateUiForCurrentItem() { updateProgressDots(); const item = currentShuffledItems[currentItemIndex]; const hasSound = item && item.sound; soundButton.classList.toggle('invisible', !hasSound); if (currentMode === 'auto') { runAutoModeStep(); } }
            function touchStart(event) { if (isNavigating || currentMode === 'auto') return; touchStartX = event.type.includes('mouse') ? event.pageX : event.touches[0].clientX; touchStartY = event.type.includes('mouse') ? event.pageY : event.touches[0].clientY; slides.forEach(s => s.classList.add('is-grabbing')); slidesWrapper.addEventListener('touchmove', touchMove); slidesWrapper.addEventListener('touchend', touchEnd); }
            function touchMove(event) { if (isNavigating || currentMode === 'auto') return; const currentX = event.type.includes('mouse') ? event.pageX : event.touches[0].clientX; const currentY = event.type.includes('mouse') ? event.pageY : event.touches[0].clientY; const deltaX = currentX - touchStartX; const deltaY = Math.abs(currentY - touchStartY); if (Math.abs(deltaX) < deltaY && !currentTranslate) return; currentTranslate = deltaX; prevSlide.style.transform = `translateX(calc(-100% + ${deltaX}px))`; currentSlide.style.transform = `translateX(${deltaX}px)`; nextSlide.style.transform = `translateX(calc(100% + ${deltaX}px))`; }
            function touchEnd() { if (currentMode === 'auto') return; slidesWrapper.removeEventListener('touchmove', touchMove); slidesWrapper.removeEventListener('touchend', touchEnd); slides.forEach(s => s.classList.remove('is-grabbing')); const threshold = slidesWrapper.clientWidth / 4; let direction = 0; if (Math.abs(currentTranslate) > threshold) { direction = currentTranslate < 0 ? -1 : 1; } moveSlider(direction); currentTranslate = 0; }
            function moveSlider(direction) { if (isNavigating || direction === 0) { if(direction === 0) setSlidePositions(); return; } if (currentMode === 'manual') { stopAllAutomation(); } isNavigating = true; let newIndex = currentItemIndex - direction; if (newIndex >= currentShuffledItems.length || (currentShuffledItems[newIndex] && currentShuffledItems[newIndex].type === 'end')) { exitCurrentExercise(); btnReshuffle.textContent = (currentSettings.order === 'chaotic') ? 'Neu mischen' : 'Neu starten'; showModal('exercise-end-modal'); isNavigating = false; return; } if (newIndex < 0) { newIndex = currentShuffledItems.length - 1; } currentItemIndex = newIndex; currentSlide.style.transform = `translateX(${direction * 100}%)`; let tempSlide; if (direction === -1) { nextSlide.style.transform = `translateX(0)`; tempSlide = prevSlide; prevSlide = currentSlide; currentSlide = nextSlide; nextSlide = tempSlide; } else { prevSlide.style.transform = `translateX(0)`; tempSlide = nextSlide; nextSlide = currentSlide; currentSlide = prevSlide; prevSlide = tempSlide; } currentSlide.addEventListener('transitionend', () => handleTransitionEnd(direction), { once: true }); updateUiForCurrentItem(); }
            function populateDisplayDurationSelect() { displayDurationSelect.innerHTML = ''; for (let i = 1; i <= 10; i++) { const option = document.createElement('option'); option.value = i; option.textContent = i === 1 ? '1 Sekunde' : `${i} Sekunden`; displayDurationSelect.appendChild(option); } displayDurationSelect.value = currentSettings.displayDuration; }
            function populateSoundDelaySelect() { soundDelaySelect.innerHTML = ''; for (let i = 0; i <= 5; i += 0.5) { const option = document.createElement('option'); option.value = i; option.textContent = i === 0 ? '0 Sek (sofort)' : `${i.toFixed(1)} Sek`; soundDelaySelect.appendChild(option); } }
            function configureSettingsScreen() { let modeText = (currentMode === 'manual') ? 'Manuell' : 'Automatisch'; settingsTitle.textContent = `Einstellungen für: ${modeText}`; const isAutoMode = currentMode === 'auto'; settingOrderGroup.classList.toggle('hidden', !isAutoMode); settingDisplayDurationGroup.classList.toggle('hidden', !isAutoMode); settingSoundOnOffGroup.classList.toggle('hidden', !isAutoMode); const showSoundDelay = isAutoMode && currentSettings.soundOn; settingSoundDelayGroup.classList.toggle('hidden', !showSoundDelay); }
            hamburgerIcon.addEventListener('click', (e) => { e.stopPropagation(); menuContent.classList.toggle('show'); if (currentMode === 'auto') { stopAllAutomation(); } });
            document.addEventListener('click', () => { if (menuContent.classList.contains('show')) menuContent.classList.remove('show'); });
            document.getElementById('menu-anleitung').addEventListener('click', (e) => { e.preventDefault(); showModal('anleitung-modal'); menuContent.classList.remove('show'); });
            document.getElementById('menu-modus-auswahl').addEventListener('click', (e) => { e.preventDefault(); exitCurrentExercise(); showScreen('screen-mode-selection'); menuContent.classList.remove('show'); });
            ['manual', 'auto'].forEach(modeKey => { document.getElementById(`menu-${modeKey}`).addEventListener('click', (e) => { e.preventDefault(); exitCurrentExercise(); currentMode = modeKey; configureSettingsScreen(); showScreen('screen-settings'); menuContent.classList.remove('show'); }); });
            modalCloseButtons.forEach(b => b.addEventListener('click', () => closeModal(b.dataset.modalId)));
            window.addEventListener('click', (e) => { if (e.target.classList.contains('modal')) closeModal(e.target.id); });
            modeCards.forEach(c => c.addEventListener('click', () => { currentMode = c.dataset.mode; configureSettingsScreen(); showScreen('screen-settings'); }));
            displayTypeButtons.forEach(b => b.addEventListener('click', () => { displayTypeButtons.forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); currentSettings.displayType = b.dataset.displayType; }));
            orderButtons.forEach(b => b.addEventListener('click', () => { orderButtons.forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); currentSettings.order = b.dataset.order; }));
            displayDurationSelect.addEventListener('change', (e) => { currentSettings.displayDuration = parseInt(e.target.value); });
            soundOnOffButtons.forEach(b => b.addEventListener('click', () => { soundOnOffButtons.forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); currentSettings.soundOn = b.dataset.soundOn === 'true'; configureSettingsScreen(); }));
            soundDelaySelect.addEventListener('change', (e) => { currentSettings.soundDelay = parseFloat(e.target.value); });
            btnSettingsBack.addEventListener('click', () => showScreen('screen-mode-selection'));
            btnStartExercise.addEventListener('click', async () => { const loaded = await loadItemSet(currentItemSetPath); if (!loaded || !currentItemSetData || currentItemSetData.length === 0) { alert("Bitte ein gültiges Set mit Inhalten auswählen."); return; } document.getElementById('loading-overlay').classList.remove('hidden'); let baseItems = [...currentItemSetData]; currentShuffledItems = (currentSettings.order === 'chaotic' && currentMode === 'auto') ? shuffleArray(baseItems) : baseItems; currentShuffledItems.push({ type: 'end' }); currentItemIndex = 0; try { await preloadAssets(currentShuffledItems); } catch (error) { console.error("Fehler beim Vorladen:", error); } generateProgressDots(); setupInitialState(); setTimeout(() => { document.getElementById('loading-overlay').classList.add('hidden'); showScreen('screen-exercise'); }, 200); });
            btnReshuffle.addEventListener('click', () => { closeModal('exercise-end-modal'); btnStartExercise.click(); });
            btnNewSelection.addEventListener('click', () => { closeModal('exercise-end-modal'); exitCurrentExercise(); showScreen('screen-settings'); });
            soundButton.addEventListener('click', () => playCurrentItemSound(0));
            navArrowsLeft.forEach(arrow => arrow.addEventListener('click', () => moveSlider(1)));
            navArrowsRight.forEach(arrow => arrow.addEventListener('click', () => moveSlider(-1)));
            btnStopAutoMode.addEventListener('click', () => { exitCurrentExercise(); configureSettingsScreen(); showScreen('screen-settings'); });
            slidesWrapper.addEventListener('touchstart', touchStart, { passive: true });

            // NEU: ANGEPASSTE App-Initialisierung
            async function initializeApp() {
                // Zuerst die Master-Liste laden, da sie die Grundlage für alles ist
                try {
                    const response = await fetch('data/master_items.json?t=' + new Date().getTime());
                    if (!response.ok) throw new Error('Master-Item-Liste (master_items.json) nicht gefunden.');
                    masterItems = await response.json();
                } catch (e) {
                    console.error("KRITISCHER FEHLER:", e);
                    // App-Start abbrechen und Fehlermeldung anzeigen
                    document.body.innerHTML = `
                        <div style="padding: 20px; text-align: center;">
                            <h1>Fehler beim Laden</h1>
                            <p>Die Haupt-Datenbank der App (master_items.json) konnte nicht geladen werden.</p>
                            <p>Bitte stellen Sie sicher, dass die Datei existiert und korrekt formatiert ist.</p>
                        </div>`;
                    return; 
                }

                // Rest der Initialisierung
                populateDisplayDurationSelect();
                populateSoundDelaySelect();
                await loadSetsManifest(); 
                showScreen('screen-mode-selection'); 
            }
            
            initializeApp();
        });
    </script>
</body>
</html>
