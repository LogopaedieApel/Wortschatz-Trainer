<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Wortschatz-Editor</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; text-align: center; vertical-align: middle;}
        td input[type="text"] { width: 98%; box-sizing: border-box; }
        .controls { margin-bottom: 20px; display: flex; align-items: center; gap: 20px; flex-wrap: wrap; }
        button { padding: 10px 15px; cursor: pointer; }
        #new-set-controls { border-left: 2px solid #ccc; padding-left: 20px; }
        #status-message { font-weight: bold; }
    </style>
</head>
<body>
    <h1>Wortschatz-Editor</h1>
    <div class="controls">
        <button id="save-button">Änderungen speichern</button>
        <p id="status-message"></p>
    </div>
    <div class="controls">
        <div id="new-set-controls">
            <input type="text" id="new-set-path" placeholder="Hierarchie/Dateiname (z.B. laute/sch/final)">
            <input type="text" id="new-set-displayname" placeholder="Anzeigename (z.B. SCH im Auslaut)">
            <button id="add-set-button">+ Neue Spalte hinzufügen</button>
        </div>
    </div>
    <table id="editor-table">
        <thead></thead>
        <tbody></tbody>
    </table>
    <div class="controls" style="margin-top: 20px;">
        <button id="add-row-button">+ Neue Zeile hinzufügen</button>
    </div>

    <script>
        let database = {};
        let manifest = {};
        let flatSets = {};

        const tableHead = document.querySelector('#editor-table thead');
        const tableBody = document.querySelector('#editor-table tbody');
        const saveButton = document.getElementById('save-button');
        const addRowButton = document.getElementById('add-row-button');
        const statusMessage = document.getElementById('status-message');
        const newSetPathInput = document.getElementById('new-set-path');
        const newSetDisplayNameInput = document.getElementById('new-set-displayname');
        const addSetButton = document.getElementById('add-set-button');

        function renderTable() {
            // 1. Gruppiere die Sets nach ihrer Oberkategorie
            const groupedSets = {};
            for (const path in flatSets) {
                const set = flatSets[path];
                if (!groupedSets[set.topCategory]) {
                    groupedSets[set.topCategory] = [];
                }
                groupedSets[set.topCategory].push({ ...set, path });
            }

            // NEU: Erstelle EINE sortierte Liste aller Spaltenpfade, die die visuelle Reihenfolge festlegt
            const orderedColumnPaths = [];
            const sortedTopCategories = Object.keys(groupedSets).sort();
            sortedTopCategories.forEach(topCategory => {
                const setsInGroup = groupedSets[topCategory];
                // Sortiere die Sets innerhalb der Gruppe (z.B. nach Anzeigenamen)
                setsInGroup.sort((a, b) => a.displayName.localeCompare(b.displayName));
                setsInGroup.forEach(set => {
                    orderedColumnPaths.push(set.path);
                });
            });

            tableHead.innerHTML = '';
            tableBody.innerHTML = '';

            // 2. Erstelle die ZWEI Kopfzeilen
            const topHeaderRow = document.createElement('tr');
            const subHeaderRow = document.createElement('tr');

            ['ID', 'Name', 'Bild', 'Ton'].forEach(text => {
                const th = document.createElement('th');
                th.rowSpan = 2;
                th.textContent = text;
                topHeaderRow.appendChild(th);
            });

            sortedTopCategories.forEach(topCategory => {
                const setsInGroup = groupedSets[topCategory];
                const topTh = document.createElement('th');
                topTh.colSpan = setsInGroup.length;
                topTh.textContent = topCategory;
                topHeaderRow.appendChild(topTh);

                setsInGroup.forEach(set => {
                    const subTh = document.createElement('th');
                    subTh.textContent = set.displayName;
                    subTh.title = set.path;
                    subHeaderRow.appendChild(subTh);
                });
            });

            tableHead.appendChild(topHeaderRow);
            tableHead.appendChild(subHeaderRow);

            // 3. Erstelle die Tabellenzeilen
            const sortedItemIds = Object.keys(database).sort();
            sortedItemIds.forEach(id => {
                const item = database[id];
                const row = document.createElement('tr');
                row.dataset.id = id;

                row.innerHTML = `
                    <td><input type="text" value="${id}" class="id-input"></td>
                    <td><input type="text" value="${item.name || ''}" data-field="name"></td>
                    <td><input type="text" value="${item.image || ''}" data-field="image"></td>
                    <td><input type="text" value="${item.sound || ''}" data-field="sound"></td>
                `;

                // VERWENDE DIESELBE SORTIERTE LISTE für die Checkboxen!
                orderedColumnPaths.forEach(path => {
                    const cell = document.createElement('td');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = flatSets[path] && flatSets[path].items.includes(id);
                    checkbox.dataset.path = path;
                    cell.style.textAlign = 'center';
                    cell.appendChild(checkbox);
                    row.appendChild(cell);
                });
                tableBody.appendChild(row);
            });
        }
        
        // Der Rest des Skripts bleibt unverändert...
        function readTableIntoState() {
            const newDatabase = {};
            const newFlatSets = JSON.parse(JSON.stringify(flatSets));
            Object.values(newFlatSets).forEach(set => set.items = []);
            const rows = tableBody.querySelectorAll('tr');
            rows.forEach(row => {
                const id = row.querySelector('.id-input').value.trim();
                if (!id) return;
                const itemData = {};
                row.querySelectorAll('input[data-field]').forEach(input => {
                    itemData[input.dataset.field] = input.value;
                });
                newDatabase[id] = itemData;
                row.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    if (checkbox.checked) {
                        const path = checkbox.dataset.path;
                        if (newFlatSets[path]) {
                            newFlatSets[path].items.push(id);
                        }
                    }
                });
            });
            database = newDatabase;
            flatSets = newFlatSets;
        }

        async function loadData() {
            try {
                statusMessage.textContent = "Lade Daten...";
                const response = await fetch('/api/get-all-data');
                if (!response.ok) throw new Error('Server-Antwort war nicht OK');
                const data = await response.json();
                database = data.database;
                manifest = data.manifest;
                flatSets = data.flatSets;
                renderTable();
                statusMessage.textContent = "Daten erfolgreich geladen.";
            } catch (error) {
                console.error('Fehler beim Laden:', error);
                statusMessage.textContent = "Fehler: Konnte Daten nicht vom Server laden.";
            }
        }

        async function saveData() {
            try {
                readTableIntoState();
                const updateManifestWithFlatData = (node) => {
                    for (const key in node) {
                        const child = node[key];
                        if (child && child.path && flatSets[child.path]) {
                            child.items = flatSets[child.path].items;
                        } else if (typeof child === 'object' && child !== null) {
                            updateManifestWithFlatData(child);
                        }
                    }
                };
                updateManifestWithFlatData(manifest);
                statusMessage.textContent = "Speichere Daten...";
                const response = await fetch('/api/save-all-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ database: database, manifest: manifest })
                });
                if (!response.ok) throw new Error('Fehler beim Speichern');
                const result = await response.json();
                statusMessage.textContent = `Erfolg: ${result.message}`;
                await loadData();
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
                statusMessage.textContent = "Fehler: Daten konnten nicht gespeichert werden.";
            }
        }

        function addNewSet() {
            const pathParts = newSetPathInput.value.trim().split('/').filter(p => p);
            const displayName = newSetDisplayNameInput.value.trim();
            if (pathParts.length === 0 || !displayName) {
                alert("Bitte Hierarchie/Dateiname und Anzeigename ausfüllen.");
                return;
            }
            readTableIntoState();
            const newFileName = pathParts.join('_') + '.json';
            const newPath = `data/sets/${newFileName}`;
            if (flatSets[newPath]) {
                 alert('Ein Set mit diesem Pfad existiert bereits.');
                return;
            }
            flatSets[newPath] = { displayName: displayName, items: [], topCategory: pathParts[0] };
            let currentLevel = manifest;
            for(let i = 0; i < pathParts.length - 1; i++) {
                const part = pathParts[i];
                if (!currentLevel[part] || typeof currentLevel[part] !== 'object' || Array.isArray(currentLevel[part])) {
                     currentLevel[part] = { displayName: part.charAt(0).toUpperCase() + part.slice(1) };
                }
                currentLevel = currentLevel[part];
            }
            const finalKey = pathParts[pathParts.length - 1];
            currentLevel[finalKey] = { displayName: displayName, path: newPath };
            newSetPathInput.value = '';
            newSetDisplayNameInput.value = '';
            renderTable();
            statusMessage.textContent = `Neue Kategorie "${displayName}" hinzugefügt. Vergessen Sie nicht zu speichern.`;
        }

        saveButton.addEventListener('click', saveData);
        addRowButton.addEventListener('click', () => {
            readTableIntoState();
            const newId = `neues_item_${Date.now()}`;
            database[newId] = { name: 'Neues Wort', image: '', sound: ''};
            renderTable();
        });
        addSetButton.addEventListener('click', addNewSet);
        document.addEventListener('DOMContentLoaded', loadData);
    </script>
</body>
</html>